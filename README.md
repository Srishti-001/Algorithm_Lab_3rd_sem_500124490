# Algorithm_Lab_3rd_sem_500124490

Lab 1: Binary Search Tree Insertion (Iterative and Recursive)
This folder contains the implementation of iterative and recursive insertion in a binary search tree (BST). The C code compares their performance in terms of time complexity. The Python code takes inputs and visualizes the BST after insertion. Screenshots of the resulting BST and performance comparison are included.

Lab 2: Merge Sort vs Quick Sort
This folder contains the implementation of Merge Sort and Quick Sort algorithms using the divide and conquer approach. Both sorting techniques are compared for the same set of elements. The Python code visualizes the sorted outputs. Graph screenshots and performance comparison results are provided.

Lab 3: Strassenâ€™s Matrix Multiplication vs Traditional Matrix Multiplication
This folder includes implementations of the Strassen method of matrix multiplication and the traditional method. Their performances are compared for different matrix sizes. The Python code shows visual output for the matrices. Screenshots of performance comparisons and graph visualizations are included.

Lab 4: Activity Selection Problem (Greedy Approach)
This folder demonstrates the implementation of the Activity Selection Problem using a greedy approach. The solution selects the maximum number of compatible activities, C code output comparisons are provided.

Lab 5: Matrix Chain Multiplication (Dynamic Programming)
This folder contains the implementation of the Matrix Chain Multiplication problem using dynamic programming. It also illustrates the impact of parenthesis positioning on the time complexity. The Python code visualizes matrix operations based on input. Screenshots of performance results and graphs are included.

Lab 6: Dijkstra vs Bellman-Ford (Single Source Shortest Path)
This folder compares the performance of Dijkstra's Algorithm and Bellman-Ford Algorithm for solving the single-source shortest path problem. Both algorithms are implemented in C, while the Python code generates visual representations of the graph. Graph screenshots and performance comparisons are included.

Lab 7: 0/1 Knapsack Problem (Greedy vs Dynamic Programming)
This folder contains the implementation of the 0/1 Knapsack Problem using both the greedy approach and dynamic programming. The performance of both methods is compared for the same dataset. The Python code visualizes the results. Graph screenshots and output comparisons are included.

Lab 8: Sum of Subsets Problem
This folder includes the implementation of the Sum of Subsets Problem using backtracking. The C code finds all subsets of a set that sum to a target value. The Python code visualizes the process of finding subsets. Screenshots of results and graph visualizations are provided.

Lab 9: 0/1 Knapsack Problem (Backtracking, Branch & Bound, and Dynamic Programming)
This folder compares the performance of Backtracking, Branch & Bound, and Dynamic Programming approaches to the 0/1 Knapsack Problem. The C code implements all three methods, while the Python code visualizes their results. Graph screenshots and performance comparisons are included.

Lab 10: String Matching Algorithms (Rabin-Karp, KMP, and Naive)
This folder compares the performance of Rabin-Karp, Knuth-Morris-Pratt (KMP), and the Naive String Matching algorithms. The C code implements each algorithm, and the Python code visualizes string matching results. Graph screenshots and comparisons of the algorithms' performance are provided.
