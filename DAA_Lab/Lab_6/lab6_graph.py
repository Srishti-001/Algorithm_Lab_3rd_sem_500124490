# -*- coding: utf-8 -*-
"""Lab6_Graph

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kckzwXxEfUmpoTeNK1FAl4LlGHOrZfVh
"""

import heapq
import networkx as nx
import matplotlib.pyplot as plt

# Dijkstra's Algorithm
def dijkstra(graph, src, V):
    dist = [float('inf')] * V  # Initialize distances as infinity
    dist[src] = 0  # Distance from source to itself is 0
    priority_queue = [(0, src)]  # Priority queue to select minimum distance node

    while priority_queue:
        current_dist, u = heapq.heappop(priority_queue)  # Get vertex with minimum distance

        # Explore all adjacent vertices
        for v, weight in graph[u]:
            if dist[u] + weight < dist[v]:
                dist[v] = dist[u] + weight
                heapq.heappush(priority_queue, (dist[v], v))  # Push the updated distance into the priority queue

    # Print shortest distances from source
    print("Dijkstra Algorithm:")
    for i in range(V):
        print(f"Vertex {i} -> Distance from source: {dist[i]}")

# Bellman-Ford Algorithm
def bellmanFord(edges, V, E, src):
    dist = [float('inf')] * V  # Initialize distances as infinity
    dist[src] = 0  # Distance from source to itself is 0

    # Relax all edges |V| - 1 times
    for _ in range(V - 1):
        for u, v, weight in edges:
            if dist[u] != float('inf') and dist[u] + weight < dist[v]:
                dist[v] = dist[u] + weight

    # Check for negative weight cycles
    for u, v, weight in edges:
        if dist[u] != float('inf') and dist[u] + weight < dist[v]:
            print("Graph contains negative weight cycle")
            return

    # Print shortest distances from source
    print("Bellman-Ford Algorithm:")
    for i in range(V):
        print(f"Vertex {i} -> Distance from source: {dist[i]}")

# Input graph and create a visual graph
def create_graph():
    V = 5  # Number of vertices
    E = 8  # Number of edges

    # Input: graph adjacency list for Dijkstra and edge list for Bellman-Ford
    print("Enter the edges (source, destination, weight):")
    graph = [[] for _ in range(V)]
    edges = []

    for _ in range(E):
        u, v, w = map(int, input("Enter edge (u v weight): ").split())
        graph[u].append((v, w))
        graph[v].append((u, w))  # This is for undirected graph
        edges.append((u, v, w))

    return graph, edges, V, E

# Visualize the graph
def visualize_graph(edges):
    G = nx.Graph()
    for u, v, w in edges:
        G.add_edge(u, v, weight=w)

    pos = nx.spring_layout(G)
    labels = nx.get_edge_attributes(G, 'weight')
    nx.draw(G, pos, with_labels=True, node_color='lightblue', node_size=700, font_size=10)
    nx.draw_networkx_edge_labels(G, pos, edge_labels=labels)
    plt.show()

# Main function
def main():
    # Create the graph with 5 vertices and 8 edges
    graph, edges, V, E = create_graph()

    # Visualize the graph
    visualize_graph(edges)

    source = int(input("Enter the source vertex: "))

    # Run Dijkstra's algorithm
    dijkstra(graph, source, V)

    # Run Bellman-Ford algorithm
    bellmanFord(edges, V, E, source)

# Run the main function
if __name__ == "__main__":
    main()